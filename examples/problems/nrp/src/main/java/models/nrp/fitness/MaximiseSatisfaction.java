package models.nrp.fitness;

import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.xbase.lib.DoubleExtensions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.Functions.Function2;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import uk.ac.kcl.inf.mdeoptimiser.libraries.core.optimisation.IGuidanceFunction;
import uk.ac.kcl.inf.mdeoptimiser.libraries.core.optimisation.interpreter.guidance.Solution;

@SuppressWarnings("all")
public class MaximiseSatisfaction implements IGuidanceFunction {
  /**
   * Computes the overall satisfaction generated by the selected software artifacts.
   *
   * <p>The overall satisfaction is determined by the sum of all customer satisfactions (weighted by
   * their importance value). A customer's satisfaction is determined by the sum of satisfaction
   * contributions of the requirements directly desired by the customer. The contribution of such a
   * requirement, in turn, is determined by its level of fulfillment weighted by its valuation
   * assigned by the customer.
   *
   * <p>The level of fulfillment of a requirement is usually determined by the percentage to which a
   * software artifact realises the requirement. However, a requirement can be simultaneously
   * fulfilled to different degrees by different artifacts. Additionally, it can also be fulfilled
   * by a combination of other requirements. In the latter case, the level of fulfillment is
   * determined by the weighted sum of the levels of fulfillment of those dependencies. In both of
   * the above cases, the highest contribution of fulfillment will determine the overall level of
   * fulfillment of the requirement.
   *
   * <p><em>Example:</em></br> Requirement A depends on two Requirements B and C. The valuations
   * connecting A to B and C have the values v(B)=2, v(C)=4. The level of fulfillments are f(B)=0.8,
   * f(C)=0.5. The level of fulfillment for A then is f(A)=(0.8*2 + 0.5*4)/6=0.6. In case there is a
   * direct realisation for A with a percentage of 0.8 the overall level of fulfillment will be
   * max(0.6, 0.8)=0.8.
   */
  @Override
  public double computeFitness(final Solution model) {
    final Function2<Double, EObject, Double> _function =
        (Double result, EObject customer) -> {
          Object _feature = this.getFeature(customer, "importance");
          Double _calculateSatisfaction = this.calculateSatisfaction(customer);
          double _multiply =
              DoubleExtensions.operator_multiply(((Double) _feature), _calculateSatisfaction);
          return Double.valueOf(((result).doubleValue() + _multiply));
        };
    Double satisfaction =
        IterableExtensions.<EObject, Double>fold(
            this.getReferenceFeature(model.getModel(), "customers"),
            Double.valueOf(0.0d),
            _function);
    InputOutput.<String>println(("Found satisfaction: " + satisfaction));
    return ((-1) * (satisfaction).doubleValue());
  }

  /**
   * Calculates the weighted sum of all valuations of direct requirements for the given customer.
   * Direct requirements are those which do not depend on other requirements.
   */
  public Double calculateSatisfaction(final EObject customer) {
    Double _xblockexpression = null;
    {
      final Function1<EObject, Boolean> _function =
          (EObject v) -> {
            return Boolean.valueOf(
                IterableExtensions.isEmpty(this.getReferenceFeature(v, "contributesTo")));
          };
      final Iterable<EObject> directValuations =
          IterableExtensions.<EObject>filter(
              this.getReferenceFeature(customer, "assigns"), _function);
      final Iterable<EObject> maxDirectValuations = this.selectMaximalValuations(directValuations);
      _xblockexpression = this.calcOverallFulfillmentContribution(maxDirectValuations, customer);
    }
    return _xblockexpression;
  }

  /**
   * Calculates the fulfillment of the given requirement, that is the highest degree to which the
   * requirement is fulfilled by either direct realisations or a combination of dependency
   * requirements.
   */
  public Double calculateFulfillment(final EObject requirement, final EObject customer) {
    double _xblockexpression = (double) 0;
    {
      final Function1<EObject, Boolean> _function =
          (EObject r) -> {
            return Boolean.valueOf(this.isImplemented(r));
          };
      final Function1<EObject, Double> _function_1 =
          (EObject r) -> {
            Object _feature = this.getFeature(r, "percentage");
            return ((Double) _feature);
          };
      final Function2<Double, Double, Double> _function_2 =
          (Double result, Double perc) -> {
            return Double.valueOf(Math.max((result).doubleValue(), (perc).doubleValue()));
          };
      final Double maxRealisation =
          IterableExtensions.<Double, Double>fold(
              IterableExtensions.<EObject, Double>map(
                  IterableExtensions.<EObject>filter(
                      this.getReferenceFeature(requirement, "realisations"), _function),
                  _function_1),
              Double.valueOf(0.0d),
              _function_2);
      final Iterable<EObject> dependencyValuations =
          this.getDependencyValuations(requirement, customer);
      double aggregatedDepFulfillments = 0.0d;
      boolean _isNullOrEmpty = IterableExtensions.isNullOrEmpty(dependencyValuations);
      boolean _not = (!_isNullOrEmpty);
      if (_not) {
        final Iterable<EObject> maxDependencyValuations =
            this.selectMaximalValuations(dependencyValuations);
        aggregatedDepFulfillments =
            (this.calcOverallFulfillmentContribution(maxDependencyValuations, customer))
                .doubleValue();
      }
      _xblockexpression = Math.max((maxRealisation).doubleValue(), aggregatedDepFulfillments);
    }
    return Double.valueOf(_xblockexpression);
  }

  /**
   * Returns an iterable with all valuations of requirements which the given requirement depends on
   * and which have been assigned by the given customer.
   */
  public Iterable<EObject> getDependencyValuations(
      final EObject requirement, final EObject customer) {
    final Function1<EObject, Boolean> _function =
        (EObject v) -> {
          final Function1<EObject, Boolean> _function_1 =
              (EObject c) -> {
                return Boolean.valueOf((c == customer));
              };
          return Boolean.valueOf(
              IterableExtensions.<EObject>exists(
                  this.getReferenceFeature(v, "assignedBy"), _function_1));
        };
    return IterableExtensions.<EObject>filter(
        this.getReferenceFeature(requirement, "combines"), _function);
  }

  /**
   * From the given valuations select only those which are maximal. In other words, if multiple
   * valuations reference the same requirement, only the one with the highest value will be
   * selected. If multiple valuations with the maximum value exist, only one of them will be
   * selected.
   */
  public Iterable<EObject> selectMaximalValuations(final Iterable<EObject> valuations) {
    final Function1<EObject, Boolean> _function =
        (EObject v1) -> {
          final Function1<EObject, Boolean> _function_1 =
              (EObject v2) -> {
                return Boolean.valueOf(
                    (((v1 != v2)
                            && (this.getFeature(v1, "requirement")
                                == this.getFeature(v2, "requirement")))
                        && (((Double) this.getFeature(v1, "value"))
                                .compareTo(((Double) this.getFeature(v2, "value")))
                            <= 0)));
              };
          return Boolean.valueOf(IterableExtensions.<EObject>exists(valuations, _function_1));
        };
    return IterableExtensions.<EObject>reject(valuations, _function);
  }

  /**
   * Sums up the fulfillment contributions of the requirements referenced by the given valuations
   * regarding the weight imposed by these valuations.
   */
  public Double calcOverallFulfillmentContribution(
      final Iterable<EObject> valuations, final EObject customer) {
    double _xblockexpression = (double) 0;
    {
      final Function1<EObject, Boolean> _function =
          (EObject v) -> {
            Object _feature = this.getFeature(v, "value");
            return Boolean.valueOf(((((Double) _feature)).doubleValue() < 0.0d));
          };
      boolean _exists = IterableExtensions.<EObject>exists(valuations, _function);
      if (_exists) {
        throw new IllegalArgumentException("Valuation values need to be greater than 0.");
      }
      final Function1<EObject, Double> _function_1 =
          (EObject v) -> {
            Object _feature = this.getFeature(v, "value");
            return ((Double) _feature);
          };
      final Function2<Double, Double, Double> _function_2 =
          (Double result, Double value) -> {
            return Double.valueOf(DoubleExtensions.operator_plus(result, value));
          };
      final Double sumOfWeights =
          IterableExtensions.<Double, Double>fold(
              IterableExtensions.<EObject, Double>map(valuations, _function_1),
              Double.valueOf(0.0d),
              _function_2);
      if (((sumOfWeights).doubleValue() == 0.0d)) {
        throw new IllegalArgumentException("The sum of valuation values may not be 0.");
      }
      final Function1<EObject, Double> _function_3 =
          (EObject v) -> {
            Object _feature = this.getFeature(v, "value");
            Object _feature_1 = this.getFeature(v, "requirement");
            Double _calculateFulfillment =
                this.calculateFulfillment(((EObject) _feature_1), customer);
            return Double.valueOf(
                DoubleExtensions.operator_multiply(((Double) _feature), _calculateFulfillment));
          };
      final Function2<Double, Double, Double> _function_4 =
          (Double result, Double weightedValue) -> {
            return Double.valueOf(DoubleExtensions.operator_plus(result, weightedValue));
          };
      Double _fold =
          IterableExtensions.<Double, Double>fold(
              IterableExtensions.<EObject, Double>map(valuations, _function_3),
              Double.valueOf(0.0d),
              _function_4);
      _xblockexpression = DoubleExtensions.operator_divide(_fold, sumOfWeights);
    }
    return Double.valueOf(_xblockexpression);
  }

  /**
   * Checks if a realisation is implemented. That is, if all artifacts the realisation directly or
   * indirectly depends on are selected in the solution.
   */
  public boolean isImplemented(final EObject realisation) {
    final Function1<EObject, Boolean> _function =
        (EObject sa) -> {
          return Boolean.valueOf(
              (this.isSelected(sa)
                  && IterableExtensions.<EObject>forall(
                      this.getReferenceFeature(sa, "requires"),
                      ((Function1<EObject, Boolean>)
                          (EObject reqSa) -> {
                            return Boolean.valueOf(this.isSelected(reqSa));
                          }))));
        };
    return IterableExtensions.<EObject>forall(
        this.getReferenceFeature(realisation, "dependsOn"), _function);
  }

  public boolean isSelected(final EObject softwareArtifact) {
    EObject _head =
        IterableExtensions.<EObject>head(this.getReferenceFeature(softwareArtifact, "solutions"));
    return (_head != null);
  }

  public Object getFeature(final EObject o, final String feature) {
    Object _xblockexpression = null;
    {
      if ((o == null)) {
        InputOutput.<String>println("Null object given");
      }
      _xblockexpression = o.eGet(o.eClass().getEStructuralFeature(feature));
    }
    return _xblockexpression;
  }

  public Iterable<EObject> getReferenceFeature(final EObject o, final String feature) {
    final Object object = this.getFeature(o, feature);
    BasicEList<EObject> features = new BasicEList<EObject>();
    if ((object instanceof EObject)) {
      features.add(((EObject) object));
    } else {
      features = ((BasicEList<EObject>) object);
    }
    return features;
  }

  @Override
  public String getName() {
    return "Maximise Next Release Customer Satisfaction";
  }
}
