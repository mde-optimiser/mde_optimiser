package models.nrp.fitness;

import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;
import models.nrp.nextReleaseProblem.*;
import uk.ac.kcl.inf.mdeoptimiser.libraries.core.optimisation.IGuidanceFunction;
import uk.ac.kcl.inf.mdeoptimiser.libraries.core.optimisation.interpreter.guidance.Solution;

public class MaximiseSatisfactionReimplemented implements IGuidanceFunction {

  /**
   * Computes the overall satisfaction generated by the selected software artifacts.
   *
   * <p>The overall satisfaction is determined by the sum of all customer satisfactions (weighted by
   * their importance value). A customer's satisfaction is determined by the sum of satisfaction
   * contributions of the requirements directly desired by the customer. The contribution of such a
   * requirement, in turn, is determined by its level of fulfillment weighted by its valuation
   * assigned by the customer.
   *
   * <p>The level of fulfillment of a requirement is usually determined by the percentage to which a
   * software artifact realises the requirement. However, a requirement can be simultaneously
   * fulfilled to different degrees by different artifacts. Additionally, it can also be fulfilled
   * by a combination of other requirements. In the latter case, the level of fulfillment is
   * determined by the weighted sum of the levels of fulfillment of those dependencies. In both of
   * the above cases, the highest contribution of fulfillment will determine the overall level of
   * fulfillment of the requirement.
   *
   * <p><em>Example:</em></br> Requirement A depends on two Requirements B and C. The valuations
   * connecting A to B and C have the values v(B)=2, v(C)=4. The level of fulfillments are f(B)=0.8,
   * f(C)=0.5. The level of fulfillment for A then is f(A)=(0.8*2 + 0.5*4)/6=0.6. In case there is a
   * direct realisation for A with a percentage of 0.8 the overall level of fulfillment will be
   * max(0.6, 0.8)=0.8.
   */
  @Override
  public double computeFitness(Solution solution) {

    var nextRelease = (NRP) solution.getModel();

    var satisfaction =
        nextRelease.getCustomers().stream()
            .mapToDouble(
                customer ->
                    customer.getImportance()
                        * ((customer.getImportance() * calculateSatisfaction(customer))))
            .sum();

    System.out.println("Found satisfaction: " + satisfaction);

    return -1 * satisfaction;
  }

  /**
   * Calculates the weighted sum of all valuations of direct requirements for the given customer.
   * Direct requirements are those which do not depend on other requirements.
   */
  public Double calculateSatisfaction(Customer customer) {

    var directValuations =
        customer.getAssigns().stream()
            .filter(assignment -> assignment.getContributesTo().isEmpty())
            .collect(Collectors.toList());

    var maxDirectValuations = selectMaximalValuations(directValuations);
    return calcOverallFulfillmentContribution(maxDirectValuations, customer);
  }

  /**
   * Calculates the fulfillment of the given requirement, that is the highest degree to which the
   * requirement is fulfilled by either direct realisations or a combination of dependency
   * requirements.
   */
  public Double calculateFulfillment(Requirement requirement, Customer customer) {

    var maxRealisation =
        requirement.getRealisations().stream()
            .filter(this::isImplemented)
            .max(Comparator.comparing(RequirementRealisation::getPercentage))
            .get()
            .getPercentage();

    var dependencyValuations = getDependencyValuations(requirement, customer);

    var aggregatedDepFulfillments = 0.0;
    if (!dependencyValuations.isEmpty()) {
      var maxDependencyValuations = selectMaximalValuations(dependencyValuations);
      aggregatedDepFulfillments =
          calcOverallFulfillmentContribution(maxDependencyValuations, customer);
    }

    return Math.max(maxRealisation, aggregatedDepFulfillments);
  }

  /**
   * Returns an iterable with all valuations of requirements which the given requirement depends on
   * and which have been assigned by the given customer.
   */
  public List<Valuation> getDependencyValuations(Requirement requirement, Customer customer) {

    return requirement.getCombines().stream()
        .filter(valuation -> valuation.getAssignedBy().stream().anyMatch(c -> c.equals(customer)))
        .collect(Collectors.toList());
  }

  /**
   * From the given valuations select only those which are maximal. In other words, if multiple
   * valuations reference the same requirement, only the one with the highest value will be
   * selected. If multiple valuations with the maximum value exist, only one of them will be
   * selected.
   */
  public List<Valuation> selectMaximalValuations(List<Valuation> valuations) {

    return valuations.stream()
        .filter(
            v1 ->
                !valuations.stream()
                    .anyMatch(
                        v2 ->
                            !v2.equals(v1)
                                && v1.getRequirement().equals(v2.getRequirement())
                                && v1.getValue() <= v2.getValue()))
        .collect(Collectors.toList());
  }

  //  		valuations.reject(v1 | valuations.exists[v2 | v1 !== v2
  //			&& (v1.getFeature('requirement') === v2.getFeature('requirement'))
  //              && (v1.getFeature('value') as Double) <= (v2.getFeature('value') as Double)
  //          ])

  /**
   * Sums up the fulfillment contributions of the requirements referenced by the given valuations
   * regarding the weight imposed by these valuations.
   */
  public Double calcOverallFulfillmentContribution(List<Valuation> valuations, Customer customer) {

    if (valuations.stream().anyMatch(v -> v.getValue() < 0.0d)) {
      throw new IllegalArgumentException("Valuation values need to be greater than 0.");
    }

    var sumOfWeights = valuations.stream().mapToDouble(v -> v.getValue()).sum();

    if (sumOfWeights == 0.0d) {
      throw new IllegalArgumentException("The sum of valuation values may not be 0.");
    }

    var fullfillments =
        valuations.stream()
            .mapToDouble(v -> v.getValue() * calculateFulfillment(v.getRequirement(), customer))
            .sum();

    return fullfillments / sumOfWeights;
  }

  /**
   * Checks if a realisation is implemented. That is, if all artifacts the realisation directly or
   * indirectly depends on are selected in the solution.
   */
  public boolean isImplemented(RequirementRealisation realisation) {
    return realisation.getDependsOn().stream()
        .allMatch(sa -> isSelected(sa) && sa.getRequires().stream().allMatch(this::isSelected));
  }

  /**
   * Recursively check that the required softeareArtifact and its dependencies are included in the
   * solution This assumes that we only have one solution.
   *
   * @param softwareArtifact
   * @return true if the software artifact is selected and has no deps, or true if the software
   *     artifact and all its dependencies are selected.
   */
  public boolean isSelected(SoftwareArtifact softwareArtifact) {

    //	  return softwareArtifact.getSolutions().size() == 1;

    if (softwareArtifact.getRequires().isEmpty()) {
      return softwareArtifact.getSolutions().size() > 0;
    }

    return softwareArtifact.getSolutions().size() > 0
        && softwareArtifact.getRequires().stream().allMatch(this::isSelected);
  }

  @Override
  public String getName() {
    return "Maximise Next Release Customer Satisfaction";
  }
}
