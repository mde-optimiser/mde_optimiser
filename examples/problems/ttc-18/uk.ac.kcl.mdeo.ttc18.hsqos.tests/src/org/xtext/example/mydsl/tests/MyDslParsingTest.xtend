/*
 * generated by Xtext 2.12.0
 */
package org.xtext.example.mydsl.tests

import com.google.inject.Inject

import java.util.Collections
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl
import org.eclipse.xtext.resource.XtextResource
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.eclipse.xtext.util.CancelIndicator
import org.eclipse.xtext.validation.CheckMode
import org.junit.Assert
import org.junit.Test
import org.junit.runner.RunWith
import org.xtext.example.mydsl.myDsl.Model

import static org.junit.Assert.*;
import org.xtext.example.mydsl.interpreter.ExpressionInterpreter
import java.util.HashMap
import org.xtext.example.mydsl.myDsl.MetaParameter
import org.xtext.example.mydsl.myDsl.LiteralExpression
import org.junit.Before
import org.xtext.example.mydsl.myDsl.PropertyAggregation
import org.xtext.example.mydsl.myDsl.ClauseType
import org.xtext.example.mydsl.interpreter.SolutionInterpreter
import java.io.File
import com.google.common.io.Resources
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.emf.ecore.resource.ResourceSet
import java.io.FileReader
import com.google.common.io.Files
import com.google.common.base.Charsets

@RunWith(XtextRunner)
@InjectWith(MyDslInjectorProvider)
class MyDslParsingTest {
	
	@Inject
	ParseHelper<Model> parseHelper
	@Inject
	extension ValidationTestHelper
	
	// Parser tests
	
	@Test
	def void assertThatParsingHarwareResourcesAndSoftwareWorksAsExpected() {
		
		val result = parseHelper.parse(SolutionGenerator.validModel)

		assertNotNull(result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)		
		result.validate
		result.assertNoIssues
	
		val originalModelPath = "models/resource/original/models/"
		val serialisedModelPathPrefix = "models/resource/allocation/"
	
		var originalModelFiles = loadJastAddModels(originalModelPath)


		originalModelFiles.fold(new HashMap<File, EObject>, [map, file | map.put(file, parseHelper.parse(Files.toString(file, Charsets.UTF_8))) return map]).forEach[
			file, model | writeModel(model, String.format("%s/%s.xmi", serialisedModelPathPrefix, Files.getNameWithoutExtension(file.name)))
		]
	
	}
	

		
	def File[] loadJastAddModels(String rootDirectory) {
		var files = new File(rootDirectory)
		
		return new File(files.getPath).listFiles
	}
	
	
	
	
	def writeModel(EObject model, String path) {
		
		val ResourceSet resourceSet = model.eResource.resourceSet
		
		EcoreUtil2.resolveAll(model)
		
		val resource = resourceSet.createResource(URI.createURI(path))
		if (resource.loaded) {
			resource.contents.clear
		}
		resource.contents.add(model)
		resource.save(Collections.EMPTY_MAP)
	}
	
	
	// Expressions tests
	
	@Test
	def void assertThatExpressionsReturnTheExpectedValues(){

		val result = parseHelper.parse(SolutionGenerator.validModel)

		var metaParameterAssignments = result.solution.assignments.head.request.parameterAssignments
		
		val metaParametersMap = new HashMap<MetaParameter, LiteralExpression>();
		
		metaParameterAssignments.forEach[parameter |			
			metaParametersMap.put(parameter.parameter, parameter.value)	
		]
		
		val expressionAssignment = result.solution.assignments.filter[assignment | assignment.implementation.name.equals("implementation_0i1")].head
		val expressionClause = expressionAssignment.implementation.clauses.filter[clause | clause.LHS.property.name.equals("energy")].head
		assertEquals(18866.11, ExpressionInterpreter.eval(expressionClause.RHS, metaParametersMap), 0)
	}
	
	
	// Objective functions tests
	
	@Test
	def void assertThatObjectiveFunctionIsCalculatedAsExpectedForAggregationSum(){
	
		val result = parseHelper.parse(SolutionGenerator.validModel)
				
		assertEquals(34620.200000000004, SolutionInterpreter.calculateObjective(result.solution, result.objective), 0)
		
	}
	
	@Test
	def void assertThatObjectiveFunctionIsCalculatedAsExpectedForAggregationMax(){
												
		val customObjective = "minimize max(energy)"
		val result = parseHelper.parse(SolutionGenerator.getValidmodelCustomObjective(customObjective))
		
		assertEquals(18866.11, SolutionInterpreter.calculateObjective(result.solution, result.objective), 0)
		
	}
	
	
	@Test
	def void assertThatObjectiveFunctionIsCalculatedAsExpectedForAggregationSumForIncompleteModel(){
	
		var customSolution = '''
					solution {
					 request0 -> implementation_0i1 {
					  compute_resource_0 -> resource0 {
					   cpu_0 -> cpu0_0
					   ram_1 -> ram0
					   disk_1 -> disk0
					   network_1 -> network0
					  }
					  //the_component_0c0 --> implementation_0c0i0 {
					  // compute_resource_0 -> resource1 {
					  //  cpu_0 -> cpu1_0
					  //  ram_1 -> ram1
					  //  disk_1 -> disk1
					  //  network_1 -> network1
					  // }
					  }
					  the_component_0c1 --> implementation_0c1i0 {
					   compute_resource_0 -> resource2 {
					    cpu_0 -> cpu2_0
					    ram_1 -> ram2
					    disk_1 -> disk2
					    network_1 -> network2
					   }
					  }
					 }
					}
		'''
	
	
		val result = parseHelper.parse(SolutionGenerator.getValidmodelCustomSolution(customSolution))
				
		assertEquals(4.294986160110001E9, SolutionInterpreter.calculateObjective(result.solution, result.objective), 0)
		
	}

	// One implementation per component required by a request

	@Test
	def void assertThatOneImplementationPerComponentConstraintReturnsZeroForAValidSolution(){
		
		val result = parseHelper.parse(SolutionGenerator.validModel)
		
		assertEquals(0, SolutionInterpreter.checkComponentsOnlyMappedOnce(result.solution), 0)
	}
	
	/**
	 * Component 0c0 mapped twice to make solution invalid
	 */
	@Test
	def void assertThatOneImplementationPerComponentConstraintReturnsAsExpectedForAnInvalidSolution(){
		
		val customSolution = '''
				solution {
				 request0 -> implementation_0i1 {
				  compute_resource_0 -> resource0 {
				   cpu_0 -> cpu0_0
				   ram_1 -> ram0
				   disk_1 -> disk0
				   network_1 -> network0
				  }
				  the_component_0c0 --> implementation_0c0i0 {
				   compute_resource_0 -> resource1 {
				    cpu_0 -> cpu1_0
				    ram_1 -> ram1
				    disk_1 -> disk1
				    network_1 -> network1
				   }
				  }
				  the_component_0c0 --> implementation_0c1i0 {
				   compute_resource_0 -> resource0 {
				    cpu_0 -> cpu2_0
				    ram_1 -> ram2
				    disk_1 -> disk2
				    network_1 -> network2
				   }
				  }
				 }
				}
		'''
		val result = parseHelper.parse(SolutionGenerator.getValidmodelCustomSolution(customSolution))
		
		assertEquals(1, SolutionInterpreter.checkComponentsOnlyMappedOnce(result.solution), 0)
	}
	
	
	// One resource per component
	
	@Test
	def void assertThatRequestSatisfyingComponentSelectionForNonFunctionalPropertiesConstraintReturnsAsExpectedForAValidSolution(){
		
		val result = parseHelper.parse(SolutionGenerator.validModel)
		
		assertEquals(0, SolutionInterpreter.checkEachResourceHasAtMostOneImplementationMapped(result.solution), 0)
		
	}
	
	/**
	 * Check that requests are not added twice to the solution with mapped components
	 */
	@Test
	def void assertThatRequestSatisfyingComponentSelectionForNonFunctionalPropertiesConstraintReturnsAsExpectedForAnInvalidSolution(){
		val customSolution = '''
				solution {
				 request0 -> implementation_0i1 {
				  compute_resource_0 -> resource0 {
				   cpu_0 -> cpu0_0
				   ram_1 -> ram0
				   disk_1 -> disk0
				   network_1 -> network0
				  }
				  the_component_0c0 --> implementation_0c0i0 {
				   compute_resource_0 -> resource1 {
				    cpu_0 -> cpu1_0
				    ram_1 -> ram1
				    disk_1 -> disk1
				    network_1 -> network1
				   }
				  }
				  the_component_0c0 --> implementation_0c1i4 {
				   compute_resource_0 -> resource2 {
				    cpu_0 -> cpu2_0
				    ram_1 -> ram2
				    disk_1 -> disk2
				    network_1 -> network2
				   }
				  }
				 }
				 request0 -> implementation_0i1 {
				  compute_resource_0 -> resource0 {
				   cpu_0 -> cpu0_0
				   ram_1 -> ram0
				   disk_1 -> disk0
				   network_1 -> network0
				  }
				  the_component_0c0 --> implementation_0c0i0 {
				   compute_resource_0 -> resource1 {
				    cpu_0 -> cpu1_0
				    ram_1 -> ram1
				    disk_1 -> disk1
				    network_1 -> network1
				   }
				  }
				  the_component_0c0 --> implementation_0c1i4 {
				   compute_resource_0 -> resource2 {
				    cpu_0 -> cpu2_0
				    ram_1 -> ram2
				    disk_1 -> disk2
				    network_1 -> network2
				   }
				  }
				 }
				}
		'''
		val result = parseHelper.parse(SolutionGenerator.getValidmodelCustomSolution(customSolution))
				
		assertEquals(3, SolutionInterpreter.checkEachResourceHasAtMostOneImplementationMapped(result.solution), 0)	
	}
	
	// One implementation per resource tests
	
	@Test
	def void assertThatOneImplementationPerResourceConstraintReturnsAsExpectedForAValidSolution(){
				
		val result = parseHelper.parse(SolutionGenerator.validModel)
		
		assertEquals(0, SolutionInterpreter.checkEachResourceHasAtMostOneImplementationMapped(result.solution), 0)
	}
	
	@Test
	def void assertThatOneImplementationPerResourceConstraintReturnsAsExpectedForAnInvalidSolution(){
				val customSolution = '''
				solution {
				 request0 -> implementation_0i1 {
				  compute_resource_0 -> resource0 {
				   cpu_0 -> cpu0_0
				   ram_1 -> ram0
				   disk_1 -> disk0
				   network_1 -> network0
				  }
				  the_component_0c0 --> implementation_0c0i0 {
				   compute_resource_0 -> resource1 {
				    cpu_0 -> cpu1_0
				    ram_1 -> ram1
				    disk_1 -> disk1
				    network_1 -> network1
				   }
				  }
				  the_component_0c1 --> implementation_0c1i0 {
				   compute_resource_0 -> resource0 {
				    cpu_0 -> cpu2_0
				    ram_1 -> ram2
				    disk_1 -> disk2
				    network_1 -> network2
				   }
				  }
				 }
				}
		'''
		val result = parseHelper.parse(SolutionGenerator.getValidmodelCustomSolution(customSolution))
				
		assertEquals(1, SolutionInterpreter.checkEachResourceHasAtMostOneImplementationMapped(result.solution), 0)	
	}
	
	
	
	@Test
	def void assertThatAllRequestsAreFulfilledConstraintReturnsAsExpectedForAValidSolution(){
		val result = parseHelper.parse(SolutionGenerator.validModel)
		
		assertEquals(0, SolutionInterpreter.checkThatAllRequestsAreFulfilled(result.solution), 0)
	}
	
	@Test
	def void assertThatAllRequestsAreFulfilledConstraintReturnsAsExpectedForAnInvalidSolution(){
				
				val customRequests = '''
					request request0 for component_0 {
					 meta size = 144.0
					 requiring quality >= 96.0
					}
					request request0 for component_0 {
					 meta size = 144.0
					 requiring quality >= 96.0
					}
		'''
		val result = parseHelper.parse(SolutionGenerator.getValidmodelCustomRequests(customRequests))
		
		assertEquals(1, SolutionInterpreter.checkThatAllRequestsAreFulfilled(result.solution), 0)
	}
	
	
	// Check that request constraints are met by the selected components in the solution
	@Test
	def void assertThatRequestNonFunctionalRequirementsConstraitCheckReturnsAsExpectedForAValidSolution(){
		
		val result = parseHelper.parse(SolutionGenerator.validModel)
		
		assertEquals(0, SolutionInterpreter.checkAllRequestNonFunctionalRequirementsAreMet(result.solution), 0)
	}
	
	
	@Test
	def void assertThatRequestNonFunctionalRequirementsConstraitCheckReturnsAsExpectedForAnInvalidSolution(){
		
		val customRequest = '''
					request request0 for component_0 {
					 meta size = 144.0
					 requiring quality >= 100.0
					}
		'''
		
		val result = parseHelper.parse(SolutionGenerator.getValidmodelCustomRequests(customRequest))
		
		assertEquals(1, SolutionInterpreter.checkAllRequestNonFunctionalRequirementsAreMet(result.solution), 0)
	}
	
	
	
	// Check that all implementation requirements are met by the assigned sub components of the
	// requested component selected in the solution
	
	@Test
	def void assertThatRequestComponentsNonFunctionalParametersConstraintReturnsAsExpectedForAvalidSolution(){
		
		val result = parseHelper.parse(SolutionGenerator.validModel)
		result.validate
		assertEquals(0, SolutionInterpreter.checkAllImplementationRequirementsAreMet(result.solution), 0)
	}
	

	@Test
	def void assertThatRequestComponentsNonFunctionalParametersConstraintReturnsAsExpectedForAnInvalidSolution() {
		
				val hardwareModel = '''
						container resource type ComputeNode {
						 resource type CPU {
						  property frequency [Hz]
						  property load [%]
						 }
						 resource type RAM {
						  using property total
						  using property free
						 }
						 resource type DISK {
						  using property total
						  using property free
						 }
						 resource type NETWORK {
						  property latency [ms]
						  property throughput [kB/s]
						 }
						}
						resource resource4:ComputeNode {
						 resource cpu4_0:CPU {
						  frequency = 1284.0
						  load = 0.0
						 }
						 resource ram4:RAM {
						  total = 539.0
						  free = 539.0
						 }
						 resource disk4:DISK {
						  total = 8426.0
						  free = 8426.0
						 }
						 resource network4:NETWORK {
						  latency = 244.0
						  throughput = 8395.0
						 }
						}
						resource resource2:ComputeNode {
						 resource cpu2_0:CPU {
						  frequency = 2039.0
						  load = 0.0
						 }
						 resource ram2:RAM {
						  total = 8942.0
						  free = 8942.0
						 }
						 resource disk2:DISK {
						  total = 11053.0
						  free = 11053.0
						 }
						 resource network2:NETWORK {
						  latency = 663.0
						  throughput = 85379.0
						 }
						}
						resource resource3:ComputeNode {
						 resource cpu3_0:CPU {
						  frequency = 1749.0
						  load = 0.0
						 }
						 resource ram3:RAM {
						  total = 12552.0
						  free = 12552.0
						 }
						 resource disk3:DISK {
						  total = 9171.0
						  free = 9171.0
						 }
						 resource network3:NETWORK {
						  latency = 118.0
						  throughput = 57675.0
						 }
						}
						resource resource0:ComputeNode {
						 resource cpu0_0:CPU {
						  frequency = 1567.0
						  load = 0.0
						 }
						 resource ram0:RAM {
						  total = 8602.0
						  free = 8602.0
						 }
						 resource disk0:DISK {
						  total = 15771.0
						  free = 15771.0
						 }
						 resource network0:NETWORK {
						  latency = 518.0
						  throughput = 80226.0
						 }
						}
						resource resource1:ComputeNode {
						 resource cpu1_0:CPU {
						  frequency = 1714.0
						  load = 0.0
						 }
						 resource ram1:RAM {
						  total = 8263.0
						  free = 8263.0
						 }
						 resource disk1:DISK {
						  total = 8707.0
						  free = 8707.0
						 }
						 resource network1:NETWORK {
						  latency = 73.0
						  throughput = 33654.0
						 }
						}
	'''
		//Changed CPI and Network in resource1
	
		val result = parseHelper.parse(SolutionGenerator.getValidmodelCustomHardwareModel(hardwareModel))
		result.validate
		assertEquals(2, SolutionInterpreter.checkAllImplementationRequirementsAreMet(result.solution), 0)	
	}
	
		
	@Test
	def void assertThatParsingHarwareResourcesAndSoftwareWorksAsExpectedForTreeDependencies() {
		
		val result = parseHelper.parse(SolutionGenerator.validModelWithTree)

		assertNotNull(result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)		
		result.validate
		result.assertNoIssues
	}
	
	
	@Test
	def void assertThatRequestComponentsNonFunctionalParametersConstraintReturnsAsExpectedForAvalidSolutionWithTreeDependencies(){
		
		val result = parseHelper.parse(SolutionGenerator.validModelWithTree)
		result.validate
		assertEquals(0, SolutionInterpreter.checkAllImplementationRequirementsAreMet(result.solution), 0)
	}
	
	@Test
	def void assertThatRequestComponentsNonFunctionalParametersConstraintReturnsAsExpectedForAnIvalidSolutionWithTreeDependencies(){
		
		val result = parseHelper.parse(SolutionGenerator.invalidModelWithTree)
		result.validate
		assertEquals(11, SolutionInterpreter.checkAllImplementationRequirementsAreMet(result.solution), 0)
	}

	
	@Test
	def void assertThatConstraintToCheckRequiredComponentsAreImplementedReturnsAsExpectedForValidSolution(){
		val result = parseHelper.parse(SolutionGenerator.validModel)
		
		assertEquals(0, SolutionInterpreter.checkAllRequestRequiredComponentsAreImplemented(result.solution), 0)
		
	}
	
	@Test
	def void assertThatConstraintToCheckRequiredComponentsAreImplementedReturnsAsExpectedForInvalidSolution(){
		
		val customRequest = '''
					request request0 for component_0c0 {
					 meta size = 144.0
					 requiring quality >= 100.0
					}
		'''
		
		val result = parseHelper.parse(SolutionGenerator.getValidmodelCustomRequests(customRequest))
		
		assertEquals(1, SolutionInterpreter.checkAllRequestRequiredComponentsAreImplemented(result.solution), 0)
		
	}
	
	@Test
	def void assertThatConstraintToCheckThatEachRequestIsFullfilledReturnsAsExpectedForAValidSolution(){
		val result = parseHelper.parse(SolutionGenerator.validModel)
		
		assertEquals(0, SolutionInterpreter.checkThatAllRequestsAreFulfilled(result.solution), 0)
		
	}
	
	@Test
	def void assertThatConstraintToCheckThatEachRequestIsFullfilledReturnsAsExpectedForAnInalidSolution(){
		
		val customRequest = '''
					request request0 for component_0c0 {
					 meta size = 144.0
					 requiring quality >= 100.0
					}
					request request1 for component_0c0 {
					 meta size = 144.0
					 requiring quality >= 100.0
					}
		'''
		
		val result = parseHelper.parse(SolutionGenerator.getValidmodelCustomRequests(customRequest))
				
		assertEquals(1, SolutionInterpreter.checkThatAllRequestsAreFulfilled(result.solution), 0)
	}	
	
	@Test
	def void assertThatACToMinimiseNumberOfMissingComponentImplementationsReturnsAsExpectedForValidSolution(){
		val result = parseHelper.parse(SolutionGenerator.validModel)
		assertEquals(0,  SolutionInterpreter.checkAllImplementationRequirementsAreMet(result.solution, true, false, false), 0)
	}
	
	@Test
	def void assertThatACToMinimiseNumberOfMissingComponentImplementationsReturnsAsExpectedForInvalidSolution(){


				val customSolution = '''
				solution {
				 request0 -> implementation_0i1 {
				  compute_resource_0 -> resource0 {
				   cpu_0 -> cpu0_0
				   ram_1 -> ram0
				   disk_1 -> disk0
				   network_1 -> network0
				  }
				  the_component_0c0 --> implementation_0c0i0 {
				   compute_resource_0 -> resource1 {
				    cpu_0 -> cpu1_0
				    ram_1 -> ram1
				    disk_1 -> disk1
				    network_1 -> network1
				   }
				  }
				 }
				}
		'''
		val result = parseHelper.parse(SolutionGenerator.getValidmodelCustomSolution(customSolution))

		assertEquals(1, SolutionInterpreter.checkAllImplementationRequirementsAreMet(result.solution, true, false, false), 0)
	}

	
	@Test
	def void assertThatACToMinimiseNumberOfMissingRespirceMappingsReturnsAsExpectedForValidSolution(){
		val result = parseHelper.parse(SolutionGenerator.validModel)
		assertEquals(0,  SolutionInterpreter.checkAllImplementationRequirementsAreMet(result.solution, false, true, false), 0)
	}
	
	@Test
	def void assertThatACToMinimiseNumberOfMissingResourceMappingsReturnsAsExpectedForInvalidSolution(){
		
		val result = parseHelper.parse(SolutionGenerator.invalidModelWithTree)
		
		assertEquals(1, SolutionInterpreter.checkAllImplementationRequirementsAreMet(result.solution, false, true, false), 0)
	}
	
	@Test
	def void testResourceFindingHeuristic(){
		
		val result = parseHelper.parse(SolutionGenerator.validModel)
		
		result.validate
		val request = result.requests.head;
		
		var implementation = result.solution.assignments.head.implementation
		
		var resource = SolutionInterpreter.findClausesSatisfyingResource(request, implementation)
		
		assertNotNull(resource)
	}
	
}