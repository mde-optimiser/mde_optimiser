/*
 * generated by Xtext 2.12.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.myDsl.AddExpression;
import org.xtext.example.mydsl.myDsl.Assignment;
import org.xtext.example.mydsl.myDsl.Clause;
import org.xtext.example.mydsl.myDsl.Component;
import org.xtext.example.mydsl.myDsl.ComponentMapping;
import org.xtext.example.mydsl.myDsl.ComponentRequirement;
import org.xtext.example.mydsl.myDsl.CurrentResourceValue;
import org.xtext.example.mydsl.myDsl.DivExpression;
import org.xtext.example.mydsl.myDsl.HardwareModel;
import org.xtext.example.mydsl.myDsl.Implementation;
import org.xtext.example.mydsl.myDsl.Instance;
import org.xtext.example.mydsl.myDsl.LiteralExpression;
import org.xtext.example.mydsl.myDsl.MetaParameter;
import org.xtext.example.mydsl.myDsl.MetaParameterAssignment;
import org.xtext.example.mydsl.myDsl.MetaParameterDesignator;
import org.xtext.example.mydsl.myDsl.Model;
import org.xtext.example.mydsl.myDsl.MultExpression;
import org.xtext.example.mydsl.myDsl.MyDslPackage;
import org.xtext.example.mydsl.myDsl.Objective;
import org.xtext.example.mydsl.myDsl.PowExpression;
import org.xtext.example.mydsl.myDsl.Property;
import org.xtext.example.mydsl.myDsl.PropertyDesignator;
import org.xtext.example.mydsl.myDsl.PropertyDesignatorWithOptionalInstance;
import org.xtext.example.mydsl.myDsl.Request;
import org.xtext.example.mydsl.myDsl.Resource;
import org.xtext.example.mydsl.myDsl.ResourceMapping;
import org.xtext.example.mydsl.myDsl.ResourceRequirement;
import org.xtext.example.mydsl.myDsl.ResourceType;
import org.xtext.example.mydsl.myDsl.SoftwareModel;
import org.xtext.example.mydsl.myDsl.Solution;
import org.xtext.example.mydsl.myDsl.SubExpression;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyDslPackage.ADD_EXPRESSION:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getAdditionRule()
						|| action == grammarAccess.getAdditionAccess().getAddExpressionLeftAction_1_0_0_0()
						|| action == grammarAccess.getAdditionAccess().getSubExpressionLeftAction_1_0_1_0()
						|| rule == grammarAccess.getMultiplicationRule()
						|| action == grammarAccess.getMultiplicationAccess().getMultExpressionLeftAction_1_0_0_0()
						|| action == grammarAccess.getMultiplicationAccess().getDivExpressionLeftAction_1_0_1_0()
						|| rule == grammarAccess.getPowerRule()
						|| action == grammarAccess.getPowerAccess().getPowExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryExpressionRule()) {
					sequence_Addition(context, (AddExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBinaryExpressionRule()) {
					sequence_BinaryExpression(context, (AddExpression) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case MyDslPackage.CLAUSE:
				sequence_Clause(context, (Clause) semanticObject); 
				return; 
			case MyDslPackage.COMPONENT:
				sequence_Component(context, (Component) semanticObject); 
				return; 
			case MyDslPackage.COMPONENT_MAPPING:
				sequence_ComponentMapping(context, (ComponentMapping) semanticObject); 
				return; 
			case MyDslPackage.COMPONENT_REQUIREMENT:
				sequence_ComponentRequirement(context, (ComponentRequirement) semanticObject); 
				return; 
			case MyDslPackage.CURRENT_RESOURCE_VALUE:
				sequence_CurrentResourceValue(context, (CurrentResourceValue) semanticObject); 
				return; 
			case MyDslPackage.DIV_EXPRESSION:
				if (rule == grammarAccess.getBinaryExpressionRule()) {
					sequence_BinaryExpression(context, (DivExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getAdditionRule()
						|| action == grammarAccess.getAdditionAccess().getAddExpressionLeftAction_1_0_0_0()
						|| action == grammarAccess.getAdditionAccess().getSubExpressionLeftAction_1_0_1_0()
						|| rule == grammarAccess.getMultiplicationRule()
						|| action == grammarAccess.getMultiplicationAccess().getMultExpressionLeftAction_1_0_0_0()
						|| action == grammarAccess.getMultiplicationAccess().getDivExpressionLeftAction_1_0_1_0()
						|| rule == grammarAccess.getPowerRule()
						|| action == grammarAccess.getPowerAccess().getPowExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryExpressionRule()) {
					sequence_Multiplication(context, (DivExpression) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.HARDWARE_MODEL:
				sequence_HardwareModel(context, (HardwareModel) semanticObject); 
				return; 
			case MyDslPackage.IMPLEMENTATION:
				sequence_Implementation(context, (Implementation) semanticObject); 
				return; 
			case MyDslPackage.INSTANCE:
				sequence_Instance(context, (Instance) semanticObject); 
				return; 
			case MyDslPackage.LITERAL_EXPRESSION:
				sequence_LiteralExpression(context, (LiteralExpression) semanticObject); 
				return; 
			case MyDslPackage.META_PARAMETER:
				sequence_MetaParameter(context, (MetaParameter) semanticObject); 
				return; 
			case MyDslPackage.META_PARAMETER_ASSIGNMENT:
				sequence_MetaParameterAssignment(context, (MetaParameterAssignment) semanticObject); 
				return; 
			case MyDslPackage.META_PARAMETER_DESIGNATOR:
				sequence_MetaParameterDesignator(context, (MetaParameterDesignator) semanticObject); 
				return; 
			case MyDslPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case MyDslPackage.MULT_EXPRESSION:
				if (rule == grammarAccess.getBinaryExpressionRule()) {
					sequence_BinaryExpression(context, (MultExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getAdditionRule()
						|| action == grammarAccess.getAdditionAccess().getAddExpressionLeftAction_1_0_0_0()
						|| action == grammarAccess.getAdditionAccess().getSubExpressionLeftAction_1_0_1_0()
						|| rule == grammarAccess.getMultiplicationRule()
						|| action == grammarAccess.getMultiplicationAccess().getMultExpressionLeftAction_1_0_0_0()
						|| action == grammarAccess.getMultiplicationAccess().getDivExpressionLeftAction_1_0_1_0()
						|| rule == grammarAccess.getPowerRule()
						|| action == grammarAccess.getPowerAccess().getPowExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryExpressionRule()) {
					sequence_Multiplication(context, (MultExpression) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.OBJECTIVE:
				sequence_Objective(context, (Objective) semanticObject); 
				return; 
			case MyDslPackage.POW_EXPRESSION:
				if (rule == grammarAccess.getBinaryExpressionRule()) {
					sequence_BinaryExpression(context, (PowExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getAdditionRule()
						|| action == grammarAccess.getAdditionAccess().getAddExpressionLeftAction_1_0_0_0()
						|| action == grammarAccess.getAdditionAccess().getSubExpressionLeftAction_1_0_1_0()
						|| rule == grammarAccess.getMultiplicationRule()
						|| action == grammarAccess.getMultiplicationAccess().getMultExpressionLeftAction_1_0_0_0()
						|| action == grammarAccess.getMultiplicationAccess().getDivExpressionLeftAction_1_0_1_0()
						|| rule == grammarAccess.getPowerRule()
						|| action == grammarAccess.getPowerAccess().getPowExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryExpressionRule()) {
					sequence_Power(context, (PowExpression) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.PROPERTY:
				sequence_Property(context, (Property) semanticObject); 
				return; 
			case MyDslPackage.PROPERTY_DESIGNATOR:
				sequence_PropertyDesignator(context, (PropertyDesignator) semanticObject); 
				return; 
			case MyDslPackage.PROPERTY_DESIGNATOR_WITH_OPTIONAL_INSTANCE:
				sequence_PropertyDesignatorWithOptionalInstance(context, (PropertyDesignatorWithOptionalInstance) semanticObject); 
				return; 
			case MyDslPackage.REQUEST:
				sequence_Request(context, (Request) semanticObject); 
				return; 
			case MyDslPackage.RESOURCE:
				sequence_Resource(context, (Resource) semanticObject); 
				return; 
			case MyDslPackage.RESOURCE_MAPPING:
				sequence_ResourceMapping(context, (ResourceMapping) semanticObject); 
				return; 
			case MyDslPackage.RESOURCE_REQUIREMENT:
				sequence_ResourceRequirement(context, (ResourceRequirement) semanticObject); 
				return; 
			case MyDslPackage.RESOURCE_TYPE:
				sequence_ResourceType(context, (ResourceType) semanticObject); 
				return; 
			case MyDslPackage.SOFTWARE_MODEL:
				sequence_SoftwareModel(context, (SoftwareModel) semanticObject); 
				return; 
			case MyDslPackage.SOLUTION:
				sequence_Solution(context, (Solution) semanticObject); 
				return; 
			case MyDslPackage.SUB_EXPRESSION:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getAdditionRule()
						|| action == grammarAccess.getAdditionAccess().getAddExpressionLeftAction_1_0_0_0()
						|| action == grammarAccess.getAdditionAccess().getSubExpressionLeftAction_1_0_1_0()
						|| rule == grammarAccess.getMultiplicationRule()
						|| action == grammarAccess.getMultiplicationAccess().getMultExpressionLeftAction_1_0_0_0()
						|| action == grammarAccess.getMultiplicationAccess().getDivExpressionLeftAction_1_0_1_0()
						|| rule == grammarAccess.getPowerRule()
						|| action == grammarAccess.getPowerAccess().getPowExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryExpressionRule()) {
					sequence_Addition(context, (SubExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBinaryExpressionRule()) {
					sequence_BinaryExpression(context, (SubExpression) semanticObject); 
					return; 
				}
				else break;
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns AddExpression
	 *     Addition returns AddExpression
	 *     Addition.AddExpression_1_0_0_0 returns AddExpression
	 *     Addition.SubExpression_1_0_1_0 returns AddExpression
	 *     Multiplication returns AddExpression
	 *     Multiplication.MultExpression_1_0_0_0 returns AddExpression
	 *     Multiplication.DivExpression_1_0_1_0 returns AddExpression
	 *     Power returns AddExpression
	 *     Power.PowExpression_1_0 returns AddExpression
	 *     PrimaryExpression returns AddExpression
	 *
	 * Constraint:
	 *     (left=Addition_AddExpression_1_0_0_0 right=Addition)
	 */
	protected void sequence_Addition(ISerializationContext context, AddExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ADD_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ADD_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ADD_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ADD_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionAccess().getAddExpressionLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionAccess().getRightAdditionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns SubExpression
	 *     Addition returns SubExpression
	 *     Addition.AddExpression_1_0_0_0 returns SubExpression
	 *     Addition.SubExpression_1_0_1_0 returns SubExpression
	 *     Multiplication returns SubExpression
	 *     Multiplication.MultExpression_1_0_0_0 returns SubExpression
	 *     Multiplication.DivExpression_1_0_1_0 returns SubExpression
	 *     Power returns SubExpression
	 *     Power.PowExpression_1_0 returns SubExpression
	 *     PrimaryExpression returns SubExpression
	 *
	 * Constraint:
	 *     (left=Addition_SubExpression_1_0_1_0 right=Addition)
	 */
	protected void sequence_Addition(ISerializationContext context, SubExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SUB_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SUB_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SUB_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SUB_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionAccess().getSubExpressionLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionAccess().getRightAdditionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (request=[Request|ID]? implementation=[Implementation|ID] resourceMappings+=ResourceMapping+ componentMappings+=ComponentMapping*)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BinaryExpression returns AddExpression
	 *
	 * Constraint:
	 *     {AddExpression}
	 */
	protected void sequence_BinaryExpression(ISerializationContext context, AddExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BinaryExpression returns DivExpression
	 *
	 * Constraint:
	 *     {DivExpression}
	 */
	protected void sequence_BinaryExpression(ISerializationContext context, DivExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BinaryExpression returns MultExpression
	 *
	 * Constraint:
	 *     {MultExpression}
	 */
	protected void sequence_BinaryExpression(ISerializationContext context, MultExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BinaryExpression returns PowExpression
	 *
	 * Constraint:
	 *     {PowExpression}
	 */
	protected void sequence_BinaryExpression(ISerializationContext context, PowExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BinaryExpression returns SubExpression
	 *
	 * Constraint:
	 *     {SubExpression}
	 */
	protected void sequence_BinaryExpression(ISerializationContext context, SubExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Clause
	 *
	 * Constraint:
	 *     (type=ClauseType LHS=PropertyDesignatorWithOptionalInstance comp=ClauseComparator RHS=Expression)
	 */
	protected void sequence_Clause(ISerializationContext context, Clause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CLAUSE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CLAUSE__TYPE));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CLAUSE__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CLAUSE__LHS));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CLAUSE__COMP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CLAUSE__COMP));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CLAUSE__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CLAUSE__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClauseAccess().getTypeClauseTypeEnumRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getClauseAccess().getLHSPropertyDesignatorWithOptionalInstanceParserRuleCall_1_0(), semanticObject.getLHS());
		feeder.accept(grammarAccess.getClauseAccess().getCompClauseComparatorEnumRuleCall_2_0(), semanticObject.getComp());
		feeder.accept(grammarAccess.getClauseAccess().getRHSExpressionParserRuleCall_3_0(), semanticObject.getRHS());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ComponentMapping returns ComponentMapping
	 *
	 * Constraint:
	 *     (component=[Instance|ID] assignment=Assignment)
	 */
	protected void sequence_ComponentMapping(ISerializationContext context, ComponentMapping semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.COMPONENT_MAPPING__COMPONENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.COMPONENT_MAPPING__COMPONENT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.COMPONENT_MAPPING__ASSIGNMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.COMPONENT_MAPPING__ASSIGNMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComponentMappingAccess().getComponentInstanceIDTerminalRuleCall_0_0_1(), semanticObject.eGet(MyDslPackage.Literals.COMPONENT_MAPPING__COMPONENT, false));
		feeder.accept(grammarAccess.getComponentMappingAccess().getAssignmentAssignmentParserRuleCall_2_0(), semanticObject.getAssignment());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ComponentRequirement returns ComponentRequirement
	 *
	 * Constraint:
	 *     (instance=Instance type=[Component|ID])
	 */
	protected void sequence_ComponentRequirement(ISerializationContext context, ComponentRequirement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.COMPONENT_REQUIREMENT__INSTANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.COMPONENT_REQUIREMENT__INSTANCE));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.COMPONENT_REQUIREMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.COMPONENT_REQUIREMENT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComponentRequirementAccess().getInstanceInstanceParserRuleCall_1_0(), semanticObject.getInstance());
		feeder.accept(grammarAccess.getComponentRequirementAccess().getTypeComponentIDTerminalRuleCall_4_0_1(), semanticObject.eGet(MyDslPackage.Literals.COMPONENT_REQUIREMENT__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Component returns Component
	 *
	 * Constraint:
	 *     (name=ID usedProperties+=[Property|ID]* implementations+=Implementation+ usedProperties+=[Property|ID]*)
	 */
	protected void sequence_Component(ISerializationContext context, Component semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CurrentResourceValue returns CurrentResourceValue
	 *
	 * Constraint:
	 *     (property=[Property|ID] value=LiteralExpression)
	 */
	protected void sequence_CurrentResourceValue(ISerializationContext context, CurrentResourceValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CURRENT_RESOURCE_VALUE__PROPERTY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CURRENT_RESOURCE_VALUE__PROPERTY));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CURRENT_RESOURCE_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CURRENT_RESOURCE_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCurrentResourceValueAccess().getPropertyPropertyIDTerminalRuleCall_0_0_1(), semanticObject.eGet(MyDslPackage.Literals.CURRENT_RESOURCE_VALUE__PROPERTY, false));
		feeder.accept(grammarAccess.getCurrentResourceValueAccess().getValueLiteralExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     HardwareModel returns HardwareModel
	 *
	 * Constraint:
	 *     (properties+=Property* resourceTypes+=ResourceType+ resources+=Resource+)
	 */
	protected void sequence_HardwareModel(ISerializationContext context, HardwareModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Implementation returns Implementation
	 *
	 * Constraint:
	 *     (name=ID componentRequirements+=ComponentRequirement* resourceRequirements+=ResourceRequirement+ clauses+=Clause+)
	 */
	protected void sequence_Implementation(ISerializationContext context, Implementation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instance returns Instance
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Instance(ISerializationContext context, Instance semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.INSTANCE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.INSTANCE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInstanceAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LiteralExpression
	 *     Addition returns LiteralExpression
	 *     Addition.AddExpression_1_0_0_0 returns LiteralExpression
	 *     Addition.SubExpression_1_0_1_0 returns LiteralExpression
	 *     Multiplication returns LiteralExpression
	 *     Multiplication.MultExpression_1_0_0_0 returns LiteralExpression
	 *     Multiplication.DivExpression_1_0_1_0 returns LiteralExpression
	 *     Power returns LiteralExpression
	 *     Power.PowExpression_1_0 returns LiteralExpression
	 *     PrimaryExpression returns LiteralExpression
	 *     LiteralExpression returns LiteralExpression
	 *
	 * Constraint:
	 *     value=Double
	 */
	protected void sequence_LiteralExpression(ISerializationContext context, LiteralExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LITERAL_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LITERAL_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralExpressionAccess().getValueDoubleParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MetaParameterAssignment returns MetaParameterAssignment
	 *
	 * Constraint:
	 *     (parameter=[MetaParameter|ID] value=LiteralExpression)
	 */
	protected void sequence_MetaParameterAssignment(ISerializationContext context, MetaParameterAssignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.META_PARAMETER_ASSIGNMENT__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.META_PARAMETER_ASSIGNMENT__PARAMETER));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.META_PARAMETER_ASSIGNMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.META_PARAMETER_ASSIGNMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMetaParameterAssignmentAccess().getParameterMetaParameterIDTerminalRuleCall_1_0_1(), semanticObject.eGet(MyDslPackage.Literals.META_PARAMETER_ASSIGNMENT__PARAMETER, false));
		feeder.accept(grammarAccess.getMetaParameterAssignmentAccess().getValueLiteralExpressionParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MetaParameterDesignator
	 *     Addition returns MetaParameterDesignator
	 *     Addition.AddExpression_1_0_0_0 returns MetaParameterDesignator
	 *     Addition.SubExpression_1_0_1_0 returns MetaParameterDesignator
	 *     Multiplication returns MetaParameterDesignator
	 *     Multiplication.MultExpression_1_0_0_0 returns MetaParameterDesignator
	 *     Multiplication.DivExpression_1_0_1_0 returns MetaParameterDesignator
	 *     Power returns MetaParameterDesignator
	 *     Power.PowExpression_1_0 returns MetaParameterDesignator
	 *     PrimaryExpression returns MetaParameterDesignator
	 *     Designator returns MetaParameterDesignator
	 *     MetaParameterDesignator returns MetaParameterDesignator
	 *
	 * Constraint:
	 *     metaParameter=[MetaParameter|ID]
	 */
	protected void sequence_MetaParameterDesignator(ISerializationContext context, MetaParameterDesignator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.META_PARAMETER_DESIGNATOR__META_PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.META_PARAMETER_DESIGNATOR__META_PARAMETER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMetaParameterDesignatorAccess().getMetaParameterMetaParameterIDTerminalRuleCall_0_1(), semanticObject.eGet(MyDslPackage.Literals.META_PARAMETER_DESIGNATOR__META_PARAMETER, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MetaParameter returns MetaParameter
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_MetaParameter(ISerializationContext context, MetaParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.META_PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.META_PARAMETER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMetaParameterAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (hardwareModel=HardwareModel softwareModel=SoftwareModel requests+=Request+ objective=Objective solution=Solution?)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns DivExpression
	 *     Addition returns DivExpression
	 *     Addition.AddExpression_1_0_0_0 returns DivExpression
	 *     Addition.SubExpression_1_0_1_0 returns DivExpression
	 *     Multiplication returns DivExpression
	 *     Multiplication.MultExpression_1_0_0_0 returns DivExpression
	 *     Multiplication.DivExpression_1_0_1_0 returns DivExpression
	 *     Power returns DivExpression
	 *     Power.PowExpression_1_0 returns DivExpression
	 *     PrimaryExpression returns DivExpression
	 *
	 * Constraint:
	 *     (left=Multiplication_DivExpression_1_0_1_0 right=Multiplication)
	 */
	protected void sequence_Multiplication(ISerializationContext context, DivExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DIV_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DIV_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DIV_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DIV_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationAccess().getDivExpressionLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationAccess().getRightMultiplicationParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MultExpression
	 *     Addition returns MultExpression
	 *     Addition.AddExpression_1_0_0_0 returns MultExpression
	 *     Addition.SubExpression_1_0_1_0 returns MultExpression
	 *     Multiplication returns MultExpression
	 *     Multiplication.MultExpression_1_0_0_0 returns MultExpression
	 *     Multiplication.DivExpression_1_0_1_0 returns MultExpression
	 *     Power returns MultExpression
	 *     Power.PowExpression_1_0 returns MultExpression
	 *     PrimaryExpression returns MultExpression
	 *
	 * Constraint:
	 *     (left=Multiplication_MultExpression_1_0_0_0 right=Multiplication)
	 */
	protected void sequence_Multiplication(ISerializationContext context, MultExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.MULT_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.MULT_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.MULT_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.MULT_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationAccess().getMultExpressionLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationAccess().getRightMultiplicationParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Objective returns Objective
	 *
	 * Constraint:
	 *     (agg=PropertyAggregation property=[Property|ID])
	 */
	protected void sequence_Objective(ISerializationContext context, Objective semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.OBJECTIVE__AGG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.OBJECTIVE__AGG));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.OBJECTIVE__PROPERTY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.OBJECTIVE__PROPERTY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObjectiveAccess().getAggPropertyAggregationEnumRuleCall_1_0(), semanticObject.getAgg());
		feeder.accept(grammarAccess.getObjectiveAccess().getPropertyPropertyIDTerminalRuleCall_3_0_1(), semanticObject.eGet(MyDslPackage.Literals.OBJECTIVE__PROPERTY, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PowExpression
	 *     Addition returns PowExpression
	 *     Addition.AddExpression_1_0_0_0 returns PowExpression
	 *     Addition.SubExpression_1_0_1_0 returns PowExpression
	 *     Multiplication returns PowExpression
	 *     Multiplication.MultExpression_1_0_0_0 returns PowExpression
	 *     Multiplication.DivExpression_1_0_1_0 returns PowExpression
	 *     Power returns PowExpression
	 *     Power.PowExpression_1_0 returns PowExpression
	 *     PrimaryExpression returns PowExpression
	 *
	 * Constraint:
	 *     (left=Power_PowExpression_1_0 right=PrimaryExpression)
	 */
	protected void sequence_Power(ISerializationContext context, PowExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.POW_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.POW_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.POW_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.POW_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowerAccess().getPowExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPowerAccess().getRightPrimaryExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PropertyDesignatorWithOptionalInstance returns PropertyDesignatorWithOptionalInstance
	 *
	 * Constraint:
	 *     (instance=[Instance|ID]? property=[Property|ID])
	 */
	protected void sequence_PropertyDesignatorWithOptionalInstance(ISerializationContext context, PropertyDesignatorWithOptionalInstance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PropertyDesignator
	 *     Addition returns PropertyDesignator
	 *     Addition.AddExpression_1_0_0_0 returns PropertyDesignator
	 *     Addition.SubExpression_1_0_1_0 returns PropertyDesignator
	 *     Multiplication returns PropertyDesignator
	 *     Multiplication.MultExpression_1_0_0_0 returns PropertyDesignator
	 *     Multiplication.DivExpression_1_0_1_0 returns PropertyDesignator
	 *     Power returns PropertyDesignator
	 *     Power.PowExpression_1_0 returns PropertyDesignator
	 *     PrimaryExpression returns PropertyDesignator
	 *     Designator returns PropertyDesignator
	 *     PropertyDesignator returns PropertyDesignator
	 *
	 * Constraint:
	 *     (instance=[Instance|ID] property=[Property|ID])
	 */
	protected void sequence_PropertyDesignator(ISerializationContext context, PropertyDesignator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PROPERTY_DESIGNATOR__INSTANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PROPERTY_DESIGNATOR__INSTANCE));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PROPERTY_DESIGNATOR__PROPERTY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PROPERTY_DESIGNATOR__PROPERTY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPropertyDesignatorAccess().getInstanceInstanceIDTerminalRuleCall_0_0_1(), semanticObject.eGet(MyDslPackage.Literals.PROPERTY_DESIGNATOR__INSTANCE, false));
		feeder.accept(grammarAccess.getPropertyDesignatorAccess().getPropertyPropertyIDTerminalRuleCall_2_0_1(), semanticObject.eGet(MyDslPackage.Literals.PROPERTY_DESIGNATOR__PROPERTY, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Property returns Property
	 *
	 * Constraint:
	 *     (name=ID unit=UNIT)
	 */
	protected void sequence_Property(ISerializationContext context, Property semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PROPERTY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PROPERTY__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PROPERTY__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PROPERTY__UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPropertyAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPropertyAccess().getUnitUNITTerminalRuleCall_2_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Request returns Request
	 *
	 * Constraint:
	 *     (name=ID component=[Component|ID] parameterAssignments+=MetaParameterAssignment* requirements+=Clause+)
	 */
	protected void sequence_Request(ISerializationContext context, Request semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ResourceMapping returns ResourceMapping
	 *
	 * Constraint:
	 *     (requiredResource=[Instance|ID] usedResource=[Resource|ID] subMappings+=ResourceMapping*)
	 */
	protected void sequence_ResourceMapping(ISerializationContext context, ResourceMapping semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ResourceRequirement returns ResourceRequirement
	 *
	 * Constraint:
	 *     (instance=Instance type=[ResourceType|ID] resourceRequirements+=ResourceRequirement*)
	 */
	protected void sequence_ResourceRequirement(ISerializationContext context, ResourceRequirement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ResourceType returns ResourceType
	 *
	 * Constraint:
	 *     (container?='container'? name=ID resourceTypes+=ResourceType* properties+=Property* propertyReferences+=[Property|ID]*)
	 */
	protected void sequence_ResourceType(ISerializationContext context, ResourceType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Resource returns Resource
	 *
	 * Constraint:
	 *     (name=ID type=[ResourceType|ID] resources+=Resource* values+=CurrentResourceValue*)
	 */
	protected void sequence_Resource(ISerializationContext context, Resource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SoftwareModel returns SoftwareModel
	 *
	 * Constraint:
	 *     ((properties+=Property | parameters+=MetaParameter)* components+=Component+)
	 */
	protected void sequence_SoftwareModel(ISerializationContext context, SoftwareModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Solution returns Solution
	 *
	 * Constraint:
	 *     assignments+=Assignment+
	 */
	protected void sequence_Solution(ISerializationContext context, Solution semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
